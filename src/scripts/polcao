#!/usr/bin/env perl

# This script is a work in progress and its purpose is to parallelize OLCAO
# over jobs, allowing it to have multiple inputs.
#version 1.0
###############################################################################
############################ THINGS TO DO #####################################
#
#  -fix load balancing algorithm so that it correctly works similar to the
#     way that the potDim in secularEquation was thought of
#
#  -Fix the commenting, remove profanity and clear up some stuff
#
#  -Make a help subroutine
#
#  -Execution of things is a little clumsy. Can be tidy'd up.
#
#  -Look through the resetVars subroutine and remove variables that can remain
#     constant through jobs
#  -initFileNames can probably occur once as long as the vars don't get reset
#  
#  -Fix the creating folders issue
#
#  -Consider a more job server type of parallelization where when a process
#    finishes a job it gets the next job in the list rather than predetermining
#    the load balancing.
#        -This can easily be done by adding another parameter in the batchlist
#           next to the name of the subDir, a process run the jobs where
#           the parameter is equal to 0, then change it to a 1. A single
#           while loop can take care of this as all processes will look through
#           the exact same lines.  No additional calculations would be needed
#        -One problem with this is that if two processes are too close together
#           they might accidentally overlap
###############################################################################

#Initialize MPI
MPI_Init();

# Necessary Modules
use strict;
use warnings;
use Env;
use Parallel::MPI::Simple;
use StructureControl;
use lib "$OLCAO_BIN/perl5";
use POSIX qw(ceil floor);
use IO::Handle;

#Global Variables
my $batchFile;
my @batchList;
my @dirName;
my @tagNumber;
my $jobsPer;
my $proj_dir;
my $tempprojhome;

#MPI Stuff
my $mpisize;
my $mpirank;


############################################################################
## Define global variables used for the actually running of OLCAO these are
## from the old scripts
############################################################################
# Shortened environment variable names.
my $bin;
my $temp;
my $touch;

# Execution control.
my $niceValue;
my $test;
my $edge;
my $QN_n;
my $QN_l;
my $altSCF;
my $altPSCF;
my $spinPol;
my $serialxyz;

# Information about which job to run.
my $dosRun;
my $pacsRun;
my $sybdRun;
my $bondRun;
my $optcRun;
my $sigeRun;
my $waveRun;
my $dosRunSCF;
my $bondRunSCF;
my $waveRunSCF;

# Basis information.
my $scfBasis;
my $scfBasisSet;
my $scfBasisCode;
my $pscfBasis;
my $pscfBasisSet;
my $pscfBasisCode;

# Complete file and directory names.
my $OLCAOlock;
my $OLCAOkill;
my $runtime;
my $intermediate;
my $proj_home;
my $inputs;
my $energy;
my $iteration;
my $kp_scf;
my $kp_pscf;
my $kp_alt;
my $moment;
my $initPot;
my $structure;
my $olcao;
my $atomPos;
my $lattice;

# File nature components.
my $setup;
my $main;
my $intg;
my $band;
my $sybd;
my $dos;
my $bond;
my $optc;
my $pacs;
my $sige;
my $wave;

# Auxiliary suffix components.
my $loci;
my $tdos;
my $pdos;
my $elf;
my $eps1;
my $eps1i;
my $eps2;
my $cond;
my $ref;
my $pot;
my $valeRho;
my $up;
my $dn; # Down
my $upPdn; # Up + Down
my $upMdn; # Up - Down
my $minusNeut; # minus the neutral atom.  "-N"
my $profile;

# File name extensions.
my $plot;
my $raw;
my $out;
my $dat;
my $alt;
my $dx;
my $hdf;

# Eecutable names.
my @executables;
my $exeMechanism;






#Initialize the environment
&initEnv;

# Set up the default variable values for those global variables that can be
# modified on the command line
&setDefaultVars;

#Get MPI global variable
&getMPI;

#Parse the command line;
&parseCommandLine;

#Read the batch list;
&readBatchList;

#Load balance and run jobs
&bLoadAndRun;


sub initEnv
{

   $batchFile = "batchList";

}

sub setDefaultVars
{
   #Set the initial default conditions of some parameters
   $edge="gs";
   $test=0;             #Should the *Test executables be used?
   $spinPol=1;          #Use 1 for non-spinpol; use 2 for spinpol
   $pacsRun=0;          #Should a pacs task be done?
   $sybdRun=0;          #Should a sybd task be done?
   $dosRun=0;           #Should a dos task be done?
   $bondRun=0;          #Should a bond task be done?
   $optcRun=0;          #Should a optc task be done?
   $sigeRun=0;          #Should a sige task be done?
   $waveRun=0;          #Should a wave task be done?
   $dosRunSCF=0;        #Run PDOS in SCF?
   $bondRunSCF=0;       #Run bond in SCF?
   $waveRunSCF=0;       #Run wave in SCF?
   $scfBasis="fb";      #Code for which scf basis to be used. (Default is full)
   $scfBasisSet=0;   #Will be set to 1 if given explicitly on the command line
   $pscfBasis="no";  #Code for which pscf basis to be used. (Default is none)
   $pscfBasisSet=0;  #Will be set to 1 if given explicitly on the command line
   $niceValue=100;   #If unchanged, jobs will run at default priority, usually 0
   $serialxyz=0;     #If unchanged, optical jobs will compute x,y,z all at once
   $altSCF=0;        #Assume we will use the kpoints given for scf (not alt).
   $altPSCF=0;       #Assume we will use the kpoints given for pscf (not alt).

}

sub resetVars
{
#This subroutine resets all the global variables to undefined, and then sets
# them to their default values.  This is important when a processes finishes
# one job then moves to the next.

# Shortened environment variable names.
#   $bin=undef;
#   $temp=undef;
#   $touch=undef;

# Execution control.
   $niceValue=undef;
   $test=undef;
   $edge=undef;
   $QN_n=undef;
   $QN_l=undef;
   $altSCF=undef;
   $altPSCF=undef;
   $spinPol=undef;
   $serialxyz=undef;

# Information about which job to run.
   $dosRun=undef;
   $pacsRun=undef;
   $sybdRun=undef;
   $bondRun=undef;
   $optcRun=undef;
   $sigeRun=undef;
   $waveRun=undef;
   $dosRunSCF=undef;
   $bondRunSCF=undef;
   $waveRunSCF=undef;

# Basis information.
   $scfBasis=undef;
   $scfBasisSet=undef;
   $scfBasisCode=undef;
   $pscfBasis=undef;
   $pscfBasisSet=undef;
   $pscfBasisCode=undef;

# Complete file and directory names.
   $OLCAOlock=undef;
   $OLCAOkill=undef;
   $runtime=undef;
   $intermediate=undef;
#   $proj_home=undef;  #Don't reset proj_home is same for all
   $inputs=undef;
   $energy=undef;
   $iteration=undef;
   $kp_scf=undef;
   $kp_pscf=undef;
   $kp_alt=undef;
   $moment=undef;
   $initPot=undef;
   $structure=undef;
   $olcao=undef;
   $atomPos=undef;
   $lattice=undef;

# File nature components.
   $setup=undef;
   $main=undef;
   $intg=undef;
   $band=undef;
   $sybd=undef;
   $dos=undef;
   $bond=undef;
   $optc=undef;
   $pacs=undef;
   $sige=undef;
   $wave=undef;

# Auxiliary suffix components.
   $loci=undef;
   $tdos=undef;
   $pdos=undef;
   $elf=undef;
   $eps1=undef;
   $eps1i=undef;
   $eps2=undef;
   $cond=undef;
   $ref=undef;
   $pot=undef;
   $valeRho=undef;
   $up=undef;
   $dn=undef; # Down
   $upPdn=undef; # Up + Down
   $upMdn=undef; # Up - Down
   $minusNeut=undef; # minus the neutral atom.  "-N"
   $profile=undef;

# File name extensions.
   $plot=undef;
   $raw=undef;
   $out=undef;
   $dat=undef;
   $alt=undef;
   $dx=undef;
   $hdf=undef;

# Eecutable names.
   @executables=undef;
   $exeMechanism=undef;

&setDefaultVars;

}

sub getMPI
{

   $mpisize = MPI_Comm_size(MPI_COMM_WORLD);
   $mpirank = MPI_Comm_rank(MPI_COMM_WORLD);

}

sub parseCommandLine
{
   #Define Local varialbes
   my $number =0;
   my $arguement;

   #nothing to do yet

}

sub parseSubmitLine
{
   # This subroutine takes in a string taken from the submit file in the
   # project directory and parses it as if it were the command line and setting
   # apropriate global variables.

   # Define Local Variables.
   my $number = 0;
   my $argument;
   my @argarray;

   $argument= $_[0];
   chomp $argument;

   @argarray = split(/ /,"$argument");
   while ($number < $#argarray)
   {
      if ($argarray[$number] =~ "-scf")
      {
         $scfBasisSet=1;
         $scfBasis = lc("$argarray[++$number]");
      }
      elsif ($argarray[$number] =~ "-pscf")
      {
         $pscfBasisSet=1;
         $pscfBasis = lc("$argarray[++$number]");
      }
      elsif ($argarray[$number] =~ "-scfaltkp")
         {$altSCF = 1;}
      elsif ($argarray[$number] =~ "-pscfaltkp")
         {$altPSCF = 1;}
      elsif ($argarray[$number] =~ "-serialxyz")
         {$serialxyz = 1;}
      elsif ($argarray[$number] =~ "-spinpol")
         {$spinPol = 2;}
      elsif ($argarray[$number] =~ "-pacs")
      {
         $pacsRun=1;
         $edge=$argarray[++$number];
         if ($pscfBasisSet == 0)
            {$pscfBasis = "eb";}  #Extended basis
         $pscfBasisSet = 1;
      }
      elsif ($argarray[$number] =~ "-sybd")
      {
         $sybdRun=1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
         if ($pscfBasisSet == 0)
            {$pscfBasis = "fb";}  #Full Basis
         $pscfBasisSet = 1;
      }
      elsif ($argarray[$number] =~ "-dos")
      {
         $dosRun=1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
         if ($pscfBasisSet == 0)
            {$pscfBasis = "fb";}  #Full Basis
         $pscfBasisSet = 1;
      }
      elsif ($argarray[$number] =~ "-scfdos")
      {
         $dosRunSCF=1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
      }
      elsif ($argarray[$number] =~ "-bond")
      {
         $bondRun=1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
         if ($pscfBasisSet == 0)
            {$pscfBasis = "mb";}  #Minimal Basis
         $pscfBasisSet = 1;
      }
      elsif ($argarray[$number] =~ "-scfbond")
      {
         $bondRunSCF=1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
         if ($scfBasisSet == 0)
            {$scfBasis = "mb";}  #Minimal Basis
         $scfBasisSet = 1;
      }
      elsif ($argarray[$number] =~ "-optc")
      {
         $optcRun=1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
         if ($pscfBasisSet == 0)
            {$pscfBasis = "eb";}  #Extended Basis
         $pscfBasisSet = 1;
      }
      elsif ($argarray[$number] =~ "-sige")
      {
         $sigeRun = 1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
         if ($pscfBasisSet == 0)
            {$pscfBasis = "fb";}  #Full Basis
         $pscfBasisSet = 1;
      }
      elsif ($argarray[$number] =~ "-wave")
      {
         $waveRun = 1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
         if ($pscfBasisSet == 0)
            {$pscfBasis = "fb";}  #Full Basis
         $pscfBasisSet = 1;
      }
      elsif ($argarray[$number] =~ "-wavescf")
      {
         $waveRunSCF = 1;
         if (($#argarray == $number) || ($argarray[$number+1] =~ /\-/))
            {$edge = "gs";}
         else
            {$edge=$argarray[++$number];}
      }
      elsif ($argarray[$number] =~ "-help")
         {&printHelp;}
      elsif ($argarray[$number] =~ "-nice")
         {$niceValue=$argarray[++$number];}
      elsif ($argarray[$number] =~ "-test")
         {$test=1;}
      else
      {
         print STDOUT "UNKNOWN COMMAND LINE PARAMETERS $argarray[$number].".
                      " ABORTING.\n";
         exit;
      }
      $number++;
   }

   # Record the command line used to run this job.
   open (COMMANDLINE,">>command");
   print COMMANDLINE "olcao ";
   foreach $argument (0..$#argarray)
      {print COMMANDLINE "$argarray[$argument] ";}
   print COMMANDLINE "\n";
   close (COMMANDLINE);

}


sub readBatchList
{
   #Local Variables
   my $submission;
   my @values;

   #Open the submission list.
   open (LIST,"<$batchFile") || die "Cannot open $batchFile for reading.\n";

   #Read whole list of directories
   @batchList = <LIST>;

   #Extract out the directory names and tag ID numbers.
   foreach $submission (0..$#batchList)
   {
      @values = StructureControl::prepLine("",$batchList[$submission],'\s+');
      $dirName[$submission] = $values[0];
      $tagNumber[$submission] = $values[1];
   }

   #Close the batch submission list
   close (LIST);
}


sub bLoadAndRun
{
   # Local Variables
   my $loopvar;
   my $line;
   my $upper;
   my $lower;
   my $remainder;
   my $arrayElements;
   my @submitFile;
   my @submitLine; #command line parameters from the submit file in each dir
   my $counter=0;
   my @tempSubArray;
   

   #Set how many sub dirs, the project directory, jobs per process and the
   #  remainder incase it is not evenly distributable
   $arrayElements=@dirName;
   $proj_home = `pwd`;
   chomp $proj_home;
   $jobsPer = int($arrayElements / $mpisize);
   $remainder = $arrayElements % $mpisize;

   #Need to initialize the temporary home directory before anything else happens
   # so there are no complications with processes making the same directory
   # at the same time
   $bin = $OLCAO_BIN;
   $touch = $OLCAO_TOUCH;
   if ($mpirank==0){
      &projHomeTemp;
   }

   # Load Balance - Currently working to where each process will resolve a
   # number corresponding to the lines in the batchList file which lists
   # potential jobs.  If there is a remainder they will be first distributed
   # to the zeroth process and then up.
   ########################### Example ##########################
   # 11 jobs to run and 5 processes: rank 0: lower=0 , upper=3
   #                                 rank 1: lower=4 , upper=5
   #                                 rank 2: lower=6 , upper=7
   #                                 rank 3: lower=8 , upper=9
   #                                 rank 4: lower=10 , upper=11
   ##############################################################
   # The way this is currently implimented can be simplified to fewer lines.
   if ($mpirank == 0 && $remainder >= 1)
   {
      $lower = $mpirank;
      $upper = ($mpirank * $jobsPer) + $jobsPer;
   }
   elsif ($mpirank == 0 && $remainder == 0)
   {
      $lower = $mpirank;
      $upper = ($mpirank * $jobsPer) + ($jobsPer - 1);
   }
   elsif ($mpirank != 0 && $mpirank < $remainder)
   {
      $lower = ($mpirank * $jobsPer) + 1;
      $upper = ($mpirank * $jobsPer) + ($jobsPer) + 1;
   }
   else
   {
      # $mpirank > $remainder
      $lower = ($mpirank * $jobsPer) + $remainder;
      $upper = ($mpirank * $jobsPer) + ($jobsPer - 1) + $remainder;
   }

   

   #GO INTO EACH SUBDIRECTORY AND GET THE NECESSARY RUNTIME FLAGS FROM SUBMIT
   #THEN USE THOSE COMMAND LINE FLAGS TO RUN EACH PARTICULAR ONE, THE READING
   #HAS TO HAPPEN INSIDE THE LOOP SO THAT EACH PROCESS GRABS CORRECT FLAGS
   #THIS IS IMPORTANT IN THE CASE OF THE "NO TARGET" XANES CALCULATION, AND 
   #FOR THE EVENT THAT PEOPLE WANT TO SUBMIT A BUNCH OF UNRELATED JOBS WITH
   #DISSIMILAR COMPILER FLAGS
   
   #Start Running Stuff
   foreach $loopvar ($lower..$upper)
   {
      #Set the project directory for the new job
      $proj_dir="$proj_home"."/$dirName[$loopvar]";

      #open the submit file for parsing
      open (PROCSUB, "<$proj_dir/submit") ||
         die "Cannot open $proj_dir/submit for writing.\n";
      
      @submitFile= <PROCSUB>;

      foreach $line (0..$#submitFile)
      {
         if ($submitFile[$line] =~ m/\$OLCAO_BIN\/olcao /)
         {
            #Grab command line parameters from the submit file and put them
            # into an array that can be parsed later
            @tempSubArray = split(/\$OLCAO_BIN\/olcao /,$submitFile[$line]);
            chomp @tempSubArray;
            $submitLine[$counter] = $tempSubArray[$#tempSubArray];
            
            #To avoid potential conflicts, make sure the working directory
            # is the directory containing the inputs
            chdir $proj_dir;

            #Now parse the submit line to set the global variables to the
            #right values, after the job has finished running make sure
            #to init them to the default settings
            &parseSubmitLine($submitLine[$counter]);
            
            #submit line has been parsed and global variables set
   	        #now submit job
      	    &setupExeEnv;
            
	        #Run one of the requested jobs
	        &runOLCAO;

	        #Clean up any leftovers and tie up loose ends
	        &cleanUp;
            
            #reset vars for next submit routine to start job
            &resetVars;
         }
         $counter++;
      }
      close (PROCSUB);
   }

  chdir $proj_home; 
}

sub projHomeTemp
{
   #The purpose of this subroutine is to create the proj_home temp directory
   # this is to keep individual processes from trying to make the proj_home
   # temp directory all at the same time.

   my $directory;
   my @directories;
   my $found;
   
   # Get and separate the current directory.
   $directory=$proj_home;
   chomp ($directory);
   @directories = split(/\//,"$directory");

   # Look for the directory where the username is specified.  Once it is found,
   #  append the remaining directories to the temp directory.
   $found=0;
   $tempprojhome="$OLCAO_TEMP";
   foreach $directory (0..$#directories)
   {
      if($found==1)
         {$tempprojhome = "$tempprojhome"."/$directories[$directory]";}
      if("$directories[$directory]" eq "$USER")
         {$found = 1;}
   }


   # create the directory if it doesn't already exist
   if (! -e "$tempprojhome")
      {system ("$bin/mkdirhier $tempprojhome");}

}

############################################################################
############################################################################
#
#start subroutines from the previous olcao routine
#may contain significant edits in order to make them run in this environment
#
############################################################################
############################################################################

# Here we define two subroutines to be used to copy and move files.
# They will die nicely if something bad happens.
sub copy
{
   if ((! -e $_[0]) && (-e $_[1]))
   {
      print RUNTIME "$_[0] not found but $_[1] exists.  No copy done.\n";
      return();
   }
   if(system("cp -f $_[0] $_[1]") != 0)
      {die "Cannot copy $_[0] to $_[1].  Died $!";}
}

sub move
{
   if ((! -e $_[0]) && (-e $_[1]))
   {
      print RUNTIME "$_[0] not found but $_[1] exists.  No move done.\n";
      return();
   }
   if(system("mv -f $_[0] $_[1]") != 0)
      {die "Cannot move $_[0] to $_[1].  Died $!";}
}

# Define a subroutine for recording a reason for exiting to the RUNTIME file.
sub olcao_exit
{
   print RUNTIME "$_[0]\n";
   exit;
}

sub setupExeEnv
{
   # Define local variables.

   # This is done earlier
   # Set short names for environment variables.
#   $bin = $OLCAO_BIN;
#   $touch = $OLCAO_TOUCH;

   # Initialize file names and file name components.
   &initFileNames;

   # Initialize the directories to be used.
   &initDirectories;

   # Initialize the IO for storing results to RUNTIME.
   &initIO;

   # Initialize the executables and execution method.
   &initExes;

   # Set a number flag for the edge request.
   &setEdgeCode;

   # Finally, check that a lock file does not exist blocking execution.  If it
   #   doesn't, then make one so we can start running the job.
   if (-e "$temp/$OLCAOlock")
   {
      &olcao_exit("Lock file found in $temp.\n".
                  "Is another olcao script running?\n".
                  "Did an olcao script die badly?\n");
   }
   else
      {system("touch $temp/$OLCAOlock");}
}


sub initFileNames
{
   #Assign the filenames to be used throughout the program.  If they must
   #   be changed for some reason this will make that task much easier.
   #   It also provides a quick overview of all the files the program
   #   uses.  All edge dependent output files will be prefixed with the
   #   edge name when actually used.

   #MISC.
   $OLCAOkill      = "OLCAOkill";
   $OLCAOlock      = "OLCAOlock";
   $runtime        = "runtime";
   $intermediate   = "intermediate";
   $energy         = "enrg";
   $iteration      = "iter";
   $kp_scf         = "kp-scf";
   $kp_pscf        = "kp-pscf";
   $kp_alt         = "kp-alt";
   $moment         = "mgmo";  #Magnetic moment.  For spin pol calculations only.
   if ($spinPol == 1)
      {$initPot="scfV";}
   else
      {$initPot="sscfV";}
   $structure = "structure";
   $olcao     = "olcao";
   $atomPos   = "atomPos";
   $lattice   = "lattice";

   #DEFINE FILE NATURE COMPONENTS
   $setup     = "setup";
   $main      = "main";
   $intg      = "intg";
   $band      = "band";
   $sybd      = "sybd";
   $dos       = "dos";
   $bond      = "bond";
   $optc      = "optc";
   $pacs      = "pacs";
   $sige      = "sige";
   $wave      = "wave";

   #DEFINE AUXILIARY SUFFIX COMPONENTS
   $loci      = ".loci";
   $tdos      = ".t";
   $pdos      = ".p";
   $elf       = ".elf";
   $eps1      = ".eps1";
   $eps1i     = ".eps1i";
   $eps2      = ".eps2";
   $cond      = ".cond";
   $ref       = ".ref";
   $pot       = ".pot";
   $valeRho   = ".rhoV";
   $up        = ".up";
   $dn        = ".dn";
   $upPdn     = ".up+dn";
   $upMdn     = ".up-dn";
   $minusNeut = "-N"; #A suffix of a suffix.  ARG!
   $profile   = ".prof";

   #DEFINE FILENAME EXTENSIONS
   $plot  = ".plot";
   $raw   = ".raw";
   $out   = ".out";
   $dat   = ".dat";
   $dx    = ".dx";
   $hdf   = ".hdf5";
}

sub initDirectories
{
   # Define local variables.
   my @values;
   my $intermediateList; # Listing of the intermediate link as given by "ls -l".
   my $intermediateLoc;  # Location that the intermediate link points as given
                         #   by "ls -l".

   # Define the project's home directory.
   #$proj_home = `pwd`;
   #chomp($proj_home);

   # Define the location where the input files are kept.
   $inputs="$proj_dir"."/inputs";

   # Determine the location for the temporary storage directory based on the
   #   name of the current directory.
   &getTempDir;
   
#   print STDOUT "$intermediate\n";
#   print STDOUT "$inputs\n";
#   print STDOUT "$proj_dir\n";
#   exit;


   # Create the temp directory if it does not already exist.
   if (! -e "$temp")
      {system ("$bin/mkdirhier $temp");}
   

   # If a link to the temp directory does not yet exist, then create one.  If a
   #   link already exists, but points to the wrong place, then rename the
   #   existing link and create a new one.
#   system ("ls $proj_dir");
#   system ("cd $proj_dir");
#   chdir $proj_dir;
   if (! -e "$intermediate")
      {
      system ("ln -s $temp $intermediate");
      }
   else
   {
      $intermediateList = `ls -l $intermediate`;
      @values = StructureControl::prepLine("",$intermediateList,'\s+');
      $intermediateLoc = $values[$#values];
      if ($intermediateLoc ne $temp)
      {
         &move("$intermediate","$intermediate"."FIXME");
         system ("ln -s $temp $intermediate");
      }
   }
}


sub getTempDir
{
   # Define local variables.
   my $directory;
   my @directories;
   my $found;

   # Get and separate the current directory.
   $directory=$proj_dir;
   chomp ($directory);
   @directories = split(/\//,"$directory");

   # Look for the directory where the username is specified.  Once it is found,
   #   append the remaining directories to the temp directory.
   $found=0;
   $temp="$OLCAO_TEMP";
   foreach $directory (0..$#directories)
   {
      if ($found == 1)
         {$temp = "$temp"."/$directories[$directory]";}
      if ("$directories[$directory]" eq "$USER")
         {$found = 1;}
   }
}

sub initIO
{
   # Redefine STDERR to be the $runtime log file.
   close(STDERR);
   open(STDERR,">> $runtime");

   # Open the RUNTIME file for writing.
   if (-e "$proj_dir/$runtime")
      {open (RUNTIME,">> $runtime");}
   else
      {open (RUNTIME,"> $runtime");}
}

sub initExes
{
   # Define local variables.
   my $exec;
   my $scfGamma;
   my $pscfGamma;
   my $altGamma;

   # Define the base case for the executable name.  This is used for regular
   #   calculations that do not use the Gamma k-point.
   $executables[1] = "OLCAOsetup";
   $executables[2] = "OLCAOmain";
   $executables[3] = "OLCAOintg";
   $executables[4] = "OLCAOband";
   $executables[5] = "OLCAOdos";
   $executables[6] = "OLCAObond";
   $executables[7] = "OLCAOoptc";
   $executables[8] = "OLCAOwave";

   # Open the each kpoint file and check to see if it requests a gamma kpoint.
   $scfGamma  = &checkGammaKP("$kp_scf$dat");
   $pscfGamma = &checkGammaKP("$kp_pscf$dat");
   $altGamma  = &checkGammaKP("$kp_alt$dat");

   # If the altnernate kpoint set is used for either scf or pscf then use the
   #   altGamma flag for the scf or pscf.
   if ($altSCF == 1)
      {$scfGamma = $altGamma;}
   if ($altPSCF == 1)
      {$pscfGamma = $altGamma;}

   # Determine if the calculation is going to use the gamma kpoint and prepend
   #   a "g" for each of those necessary cases.
   if ($scfGamma == 1)
   {
      foreach $exec (1..2)
         {$executables[$exec] = "g" . $executables[$exec];}
   }
   if ($pscfGamma == 1)
   {
      foreach $exec (3..8)
         {$executables[$exec] = "g" . $executables[$exec];}
   }

   # Determine if the test executables should be used.  If so, then append the
   #   "Test" string.
   if ($test == 1)
   {
      foreach $exec (1..$#executables)
         {$executables[$exec] = $executables[$exec] . "Test";}
   }

   # Determine the command line execution mechanism.
   if (($niceValue > 19) || ($niceValue <-20))
      {$exeMechanism = "time";}
   else
      {$exeMechanism = "nice -n $niceValue time";}
}

sub checkGammaKP
{
   # Define passed parameters.
   my $kpointFile = $_[0];

   # Define local variables.
   my $numKP;
   my $line;
   my @values;

   open (KP,"<$inputs/$kpointFile") ||
         die "Cannot open $inputs/$kpointFile for reading.\n";
   @values = StructureControl::prepLine(\*KP,$line,'\s+');
   @values = StructureControl::prepLine(\*KP,$line,'\s+');
   $numKP  = $values[0];
   @values = StructureControl::prepLine(\*KP,$line,'\s+');
   @values = StructureControl::prepLine(\*KP,$line,'\s+');
   if (($numKP==1) && ($values[2]==0) && ($values[3]==0) && ($values[4]==0))
      {return 1;}
   else
      {return 0;}
}

sub setEdgeCode
{
   if ($edge =~ /gs/)
      {$QN_n = 0; $QN_l = 0}
   elsif ($edge =~ /1s/)
      {$QN_n = 1; $QN_l = 0}
   elsif ($edge =~ /2s/)
      {$QN_n = 2; $QN_l = 0}
   elsif ($edge =~ /2p/)
      {$QN_n = 2; $QN_l = 1}
   elsif ($edge =~ /3s/)
      {$QN_n = 3; $QN_l = 0}
   elsif ($edge =~ /3p/)
      {$QN_n = 3; $QN_l = 1}
   elsif ($edge =~ /3d/)
      {$QN_n = 3; $QN_l = 2}
   elsif ($edge =~ /4s/)
      {$QN_n = 4; $QN_l = 0}
   elsif ($edge =~ /4p/)
      {$QN_n = 4; $QN_l = 1}
   elsif ($edge =~ /4d/)
      {$QN_n = 4; $QN_l = 2}
   elsif ($edge =~ /4f/)
      {$QN_n = 4; $QN_l = 3}
   elsif ($edge =~ /5s/)
      {$QN_n = 5; $QN_l = 0}
   elsif ($edge =~ /5p/)
      {$QN_n = 5; $QN_l = 1}
   elsif ($edge =~ /5d/)
      {$QN_n = 5; $QN_l = 2}
   elsif ($edge =~ /6s/)
      {$QN_n = 6; $QN_l = 0}
   elsif ($edge =~ /6p/)
      {$QN_n = 6; $QN_l = 1}
   elsif ($edge =~ /7s/)
      {$QN_n = 7; $QN_l = 0}

   # Determine the number code for which basis set to use for scf and pscf.
   if ($scfBasis eq "mb")
      {$scfBasisCode = 1;}
   elsif ($scfBasis eq "fb")
      {$scfBasisCode = 2;}
   elsif ($scfBasis eq "eb")
      {$scfBasisCode = 3;}

   if ($pscfBasis eq "mb")
      {$pscfBasisCode = 1;}
   elsif ($pscfBasis eq "fb")
      {$pscfBasisCode = 2;}
   elsif ($pscfBasis eq "eb")
      {$pscfBasisCode = 3;}
}


sub runOLCAO
{
   # Define local variables.
   

   # Calculate the setup portion of the program.  This is independent of edge.
   if ("$scfBasis" ne "no")
      {&runTask ($setup,$scfBasis,"");}

   if ($pacsRun==1)
   {
      # We are running a pacs calculation.
      &runTask ($main,$scfBasis,"gs");
      &runTask ($intg,$pscfBasis,"gs");
      &runTask ($band,$pscfBasis,"gs");

      if ("$edge" ne "gs")
      {
         &runTask ($main,$scfBasis,$edge);

         # Now that both main calculations are done for the PACS calculation,
         #   we can update the pacs input file with the total energy difference 
         #   and the energy range.
         &updatePACS ($edge,$scfBasis,$pscfBasis);

         &runTask ($intg,$pscfBasis,$edge);
         &runTask ($band,$pscfBasis,$edge);
         &runTask ($pacs,$pscfBasis,$edge);
      }
   }
   else
   {
      # We are doing some other calculation (PDOS,SYBD,BOND,OPTC,SIGE,WAVE,etc.)
      if ("$scfBasis" ne "no")
         {&runTask ($main,$scfBasis,$edge);}
      if ("$pscfBasis" ne "no")
      {
         &runTask ($intg,$pscfBasis,$edge);
         if ($sybdRun==1)
            {&runTask ($sybd,$pscfBasis,$edge);}
         else
         {
            &runTask ($band,$pscfBasis,$edge);
            if ($dosRun==1)
               {&runTask ($dos,$pscfBasis,$edge);}
            elsif ($bondRun==1)
               {&runTask ($bond,$pscfBasis,$edge);}
            elsif ($optcRun==1)
               {&runTask ($optc,$pscfBasis,$edge);}
            elsif ($sigeRun==1)
               {&runTask ($sige,$pscfBasis,$edge);}
            elsif ($waveRun==1)
               {&runTask ($wave,$pscfBasis,$edge);}
         }
      }
   }
}


# Define a generic run task subroutine.  This subroutine will run a requested
#   task according to the input code it is given.
sub runTask
{
   # Define the passed parameters.
   my $taskName  = $_[0];
   my $taskBasis = "-".$_[1];  #Prepend a hyphen.
   my $taskEdge  = $_[2]."_";  #Append an underscore.

   # Define local variables.
   my $taskKP;
   my $taskCLP;
   my $output;
   my $alt;

   # Correct edge name for setup calculations where the edge doesn't matter.
   if ("$taskName" eq "$setup")
      {$taskEdge = "";}

   # Change the working directory to the intermediate location.
   chdir $temp;

   # Mark the date and time of the beginning of this task.
   $output=`date`;
   print RUNTIME "$taskEdge$taskName$taskBasis------------------------------\n";
   print RUNTIME "Start:  $output";

   # Identify the task kpoint file to use.
   $taskKP = &getTaskKP($taskName);

   # Determine if the alternate KPoints were used and if so assign a value to
   #   the alt string so that the outputs etc created with it can be kept
   #   separate.
   if ($taskKP =~ /kp-alt/)
      {$alt=".alt";}
   else
      {$alt="";}

   # Determine if the output for this task already exists.
   if (! -e "$proj_dir/$taskEdge$taskName$taskBasis$alt$out")
   {
      # Mark the lock file with the current executable.
      system ("echo $taskName$taskBasis | cat > $temp/$OLCAOlock");

      # Check to see if the necessary input files are in the $proj_dir
      #   directory.  If they are not, then try to copy them from the $inputs
      #   directory into the $proj_dir directory.  This is done so that a
      #   "pure" version of the input exists in the $inputs directory while a
      #   "user modifiable" version of the input exists in the $proj_dir
      #   directory.
      &checkInput($taskName,$taskBasis,$taskEdge,$taskKP);

      # Copy the task input files from the $proj_dir directory to $temp.
      &copyInput($taskName,$taskBasis,$taskEdge,$taskKP,$alt);

      # Create the proper command line parameters (CLP) for this task.
      $taskCLP = &determineCLP($taskName,$taskEdge);

      # Execute the requested task program and save the runtime data.
      &executeProgram($taskName,$taskCLP);

      # Manage the output files.
      &manageOutput($taskName,$taskBasis,$taskEdge,$taskKP,$alt);
   }
   else
   {
      print RUNTIME "\n$taskEdge$taskName$taskBasis$out file already exists.\n";
      print RUNTIME "Skipping $taskEdge$taskName$taskBasis execution.\n\n";
   }
   if ($touch==1)
      {system("touch $temp/*");}

   # Mark the date and time of the ending of this task.
   $output=`date`;
   print RUNTIME "End:  $output";

   if (-e "$OLCAOkill")
      {exit;}
}

# Obtain the name of the kpoint file to use for the current task.
sub getTaskKP
{
   my $taskName = $_[0];
   my $taskKP;

   if (("$taskName" eq "$setup") || ("$taskName" eq "$main"))
   {
      if ($altSCF == 0)
         {$taskKP = $kp_scf;}
      else
         {$taskKP = $kp_alt;}
   }
   else
   {
      if ($altPSCF == 0)
         {$taskKP = $kp_pscf;}
      else
         {$taskKP = $kp_alt;}
   }

   return $taskKP;
}


# Define the subroutine to check for the input files needed for each task.
sub checkInput
{
   # Define passed parameters.
   my $taskName  = $_[0];
   my $taskBasis = $_[1];
   my $taskEdge  = $_[2];
   my $taskKP    = $_[3];

   # Check for the primary "olcao" input file, and the system structure.
   if (! -e "$proj_dir/$olcao$dat")
      {&copy("$inputs/$olcao$dat","$proj_dir/$olcao$dat");}
   if (! -e "$proj_dir/$structure$dat")
      {&copy("$inputs/$structure$dat","$proj_dir/$structure$dat");}


   # Check for the set of kpoints needed for this task.
   if (! -e "$proj_dir/$taskKP$dat")
      {&copy("$inputs/$taskKP$dat","$proj_dir/$taskKP$dat");}


   # Check for a potential coefficient file for main.
   if ("$taskName" eq "$main")
   {
      if (! -e "$proj_dir/$initPot$dat")
         {&copy("$inputs/$initPot$dat","$proj_dir/$initPot$dat");}
   }
}

#This subroutine will copy all the data files for each type of task.
sub copyInput
{
   # Define passed parameters.
   my $taskName  = $_[0];
   my $taskBasis = $_[1];
   my $taskEdge  = $_[2];
   my $taskKP    = $_[3];
   my $alt       = $_[4];

   # Define the temporary basis tag.
   my $tempBasis = "-temp";

   # Copy in the universally required input.
   &copy("$proj_dir/$olcao$dat","fort.5");
   &copy("$proj_dir/$structure$dat","fort.4");
   &copy("$proj_dir/$taskKP$dat","fort.15");

   # Get the appropriate hdf5 stored intermediate data.
   if ("$taskName" eq "$main")
   {
      &move("$setup$taskBasis$alt$hdf","$setup$tempBasis$hdf");
      &getPotCoeffs($taskName,$taskBasis,$taskEdge);
   }
   elsif ("$taskName" eq "$intg")
      {&getPotCoeffs($taskName,$taskBasis,$taskEdge);}
   elsif (("$taskName" eq "$band") || ("$taskName" eq "$sybd"))
      {&move("$taskEdge$intg$taskBasis$alt$hdf","$intg$tempBasis$hdf");}
   elsif (("$taskName" eq "$dos") || ("$taskName" eq "$bond"))
      {&move("$taskEdge$band$taskBasis$alt$hdf","$band$tempBasis$hdf");}
   elsif (("$taskName" eq "$optc") || ("$taskName" eq "$sige"))
   {
      &move("$taskEdge$band$taskBasis$alt$hdf","$band$tempBasis$hdf");
      &move("$taskEdge$intg$taskBasis$alt$hdf","$intg$tempBasis$hdf");
   }
   elsif ("$taskName" eq "$pacs")
   {
      &move("gs_$intg$taskBasis$alt$hdf","$intg$tempBasis$hdf");
      &move("gs_$band$taskBasis$alt$hdf","$band$tempBasis$hdf");
      &move("$taskEdge$band$taskBasis$alt$hdf","$band$tempBasis.2$hdf");
   }
   elsif ("$taskName" eq "$wave")
   {
      &move("$taskEdge$band$taskBasis$alt$hdf","$band$tempBasis$hdf");
      &getPotCoeffs($taskName,$taskBasis,$taskEdge);
   }
}

sub getPotCoeffs
{
   # Define passed parameters.
   my $taskName  = $_[0];
   my $taskBasis = $_[1];
   my $taskEdge  = $_[2];

   # Define local variables.
   my $basis;
   my @altBasisList;

   # Establish the order of alternate basis sets to check for a set of
   #   potential coefficients.
   @altBasisList=("-eb","-fb","-mb");

   # Setup does not need any set of potential coefficients.
   if ("$taskName" eq "$setup")
      {return;}

   # Check for the potential from the same edge and basis of the current task.
   if (-e "$proj_dir/$taskEdge$initPot$taskBasis$dat")
   {
      &copy("$proj_dir/$taskEdge$initPot$taskBasis$dat","fort.8");
      print RUNTIME "Using $taskEdge$initPot$taskBasis$dat\n";
      return;
   }

   # Check each of the alternate basis sets for the current edge.
   foreach $basis (@altBasisList)
   {
      if (-e "$proj_dir/$taskEdge$initPot$basis$dat")
      {
         &copy("$proj_dir/$taskEdge$initPot$basis$dat","fort.8");
         print RUNTIME "Using $taskEdge$initPot$basis$dat\n";
         return;
      }
   }

   # Check the ground state of the current basis.
   if (-e "$proj_dir/gs_$initPot$taskBasis$dat")
   {
      &copy("$proj_dir/gs_$initPot$taskBasis$dat","fort.8");
      print RUNTIME "Using gs_$initPot$taskBasis$dat\n";
      return;
   }

   # Check each of the alternate basis sets for the ground state.
   foreach $basis (@altBasisList)
   {
      if (-e "$proj_dir/gs_$initPot$basis$dat")
      {
         &copy("$proj_dir/gs_$initPot$basis$dat","fort.8");
         print RUNTIME "Using gs_$initPot$basis$dat\n";
         return;
      }
   }

   # Check for the initial non-scf potential in the project home directory.
   if (-e "$proj_dir/$initPot$dat")
   {
      print RUNTIME "Using $initPot$dat from $proj_dir.\n";
      &copy("$proj_dir/$initPot$dat","fort.8");
      return;
   }

   # Check for the initial non-scf potential in the inputs directory.
   if (-e "$inputs/$initPot$dat")
   {
      print RUNTIME "Using $initPot$dat from $inputs.\n";
      &copy("$inputs/$initPot$dat","fort.8");
      return;
   }
}

# This subroutine will determine what the command line parameters for the
#   task execution should be.
sub determineCLP
{
   # Define passed parameters.
   my $taskName  = $_[0];
   my $taskEdge  = $_[1];

   # Define local variables.
   my $taskCLP;

   if ("$taskName" eq "$setup")
      {$taskCLP = "$scfBasisCode";}
   elsif ("$taskName" eq "$main")
   {
      # The first CLP indicates which basis to use.
      $taskCLP = "$scfBasisCode ";

      # The next CLPs signal the edge that should be computed for.  Note that
      #   in the case of the ground state run we simply make an explicit
      #   request for no excitation state.
      if ($taskEdge eq "gs_")
         {$taskCLP = "$taskCLP" . "0 0 ";}
      else
         {$taskCLP = "$taskCLP" . "$QN_n $QN_l ";}

      # The next CLP indicates if a dos calculation should also be done.
      $taskCLP = "$taskCLP" . "$dosRunSCF ";

      # The next CLP indicates if a bond calculation should also be done.
      $taskCLP = "$taskCLP" . "$bondRunSCF";
   }
   elsif ("$taskName" eq "$intg")
   {
      # The first CLP indicates which basis to use.
      $taskCLP = "$pscfBasisCode ";

      # This CLP indicates whether the momentum matrix should be computed.
      if ((($pacsRun == 1) && ($taskEdge =~ /gs/)) ||
           ($optcRun == 1) || ($sigeRun == 1))
         {$taskCLP = $taskCLP . "1";}
      else
         {$taskCLP = $taskCLP . "0";}
   }
   elsif ("$taskName" eq "$band")
   {
      # Do not do a sybd style calculation.
      $taskCLP = "$pscfBasisCode 0 ";

      # The next CLPs signal the edge that should be computed for.
      $taskCLP = "$taskCLP" . "$QN_n $QN_l ";
   }
   elsif ("$taskName" eq "$sybd")
   {
      # Do a sybd style calculation.
      $taskCLP = "$pscfBasisCode 1 ";

      # The next CLP signals the edge that should be computed for.
      $taskCLP = "$taskCLP" . "$QN_n $QN_l ";
   }
   elsif ("$taskName" eq "$dos")
   {
      # The first CLP indicates which basis to use.
      $taskCLP = "$pscfBasisCode ";

      # The next CLPs signal the edge that should be computed for.
      $taskCLP = "$taskCLP" . "$QN_n $QN_l ";
   }
   elsif ("$taskName" eq "$bond")
   {
      # The first CLP indicates which basis to use.
      $taskCLP = "$pscfBasisCode ";

      # The next CLPs signal the edge that should be computed for.
      $taskCLP = "$taskCLP" . "$QN_n $QN_l ";
   }
   elsif ("$taskName" eq "$optc")
   {
      # The first CLP indicates which basis to use.
      $taskCLP = "$pscfBasisCode ";

      # The second specifies that we are doing a normal optical properties
      #   calculation (dielectric function).
      $taskCLP = "$taskCLP" . "0 ";

      # The next CLPs signal the edge that should be computed for.
      $taskCLP = "$taskCLP" . "$QN_n $QN_l ";

      # The final value indicates whether or not to compute the x,y,z
      #   components in serial or all together (the default).
      $taskCLP = "$taskCLP" . "$serialxyz ";
   }
   elsif ("$taskName" eq "$pacs")
   {
      # The first CLP indicates which basis to use.
      $taskCLP = "$pscfBasisCode ";

      # The second specifies that we are doing a XANES/ELNES calculation.
      $taskCLP = "$taskCLP" . "1 ";

      # The next CLPs signal the edge that should be computed for.
      $taskCLP = "$taskCLP" . "$QN_n $QN_l ";

      # The final value indicates whether or not to compute the x,y,z
      #   components in serial or all together (the default).
      $taskCLP = "$taskCLP" . "$serialxyz ";
   }
   elsif ("$taskName" eq "$sige")
   {
      # The first CLP indicates which basis to use.
      $taskCLP = "$pscfBasisCode ";

      # The second specifies that we are doing a sigma(E) calculation.
      $taskCLP = "$taskCLP" . "2 ";

      # The next CLPs signal the edge that should be computed for.
      $taskCLP = "$taskCLP" . "$QN_n $QN_l ";

      # The final value indicates whether or not to compute the x,y,z
      #   components in serial or all together (the default).
      $taskCLP = "$taskCLP" . "$serialxyz ";
   }
   elsif ("$taskName" eq "$wave")
   {
      # The first CLP indicates which basis to use.
      $taskCLP = "$pscfBasisCode ";

      # The next CLPs signal the edge that should be computed for.
      $taskCLP = "$taskCLP" . "$QN_n $QN_l ";
   }

   # Include the spin polarization flag for all programs.
   $taskCLP = $taskCLP . " $spinPol";

   return $taskCLP;
}


# This subroutine will execute the requested fortran program.
sub executeProgram
{
   # Define passed parameters.
   my $taskName  = $_[0];
   my $taskCLP   = $_[1];

   # Define local variables.
   my $executable;
   my $output;
   my @values;

   # Get the name of the executable.
   if ("$taskName" eq "$setup")
      {$executable = $executables[1];}
   elsif ("$taskName" eq "$main")
      {$executable = $executables[2];}
   elsif ("$taskName" eq "$intg")
      {$executable = $executables[3];}
   elsif (("$taskName" eq "$band") || ("$taskName" eq "$sybd"))
      {$executable = $executables[4];}
   elsif ("$taskName" eq "$dos")
      {$executable = $executables[5];}
   elsif ("$taskName" eq "$bond")
      {$executable = $executables[6];}
   elsif (("$taskName" eq "$optc") || ("$taskName" eq "$pacs") ||
          ("$taskName" eq "$sige"))
      {$executable = $executables[7];}
   elsif ("$taskName" eq "$wave")
      {$executable = $executables[8];}


   # Call the executable
   $output = `($exeMechanism $bin/$executable $taskCLP 2>&1)`;
   print RUNTIME $output;


   # In certain cases a secondary jobs needs to be run immediately afterwards.
   if ("$taskName" eq "$sybd")
   {
      system("$OLCAO_BIN/makeSYBD -dat fort.5 -out fort.20 ".
             "-raw fort.31 -plot fort.41");
      if ($spinPol == 2) # Spin polarized case
         {system("$OLCAO_BIN/makeSYBD -dat fort.5 -out fort.20 ".
                 "-raw fort.32 -plot fort.42");}
   }
   elsif ("$taskName" eq "$optc")
   {
      # Define local variables.
      my $lineCount;
      my $optcLines;

      # Perform the kramers-kronig conversion of eps2 to eps1 and compute the
      #   energy loss function (all done in OLCAOkkc).  We need to pass the
      #   program the number of lines in the input file and which set of file
      #   numbers to use.  A 1 means use the spin up or default file numbers,
      #   and a 2 means use the spin down file numbers.
      $lineCount = `(wc -l fort.50)`;
      @values = StructureControl::prepLine("",$lineCount,'\s+');
      $optcLines = $values[0];

      # We always use the #1 file numbers.
      `($bin/OLCAOkkc $optcLines 1 2>&1)`;

      # We only use the #2 set of file numbers for the spin polarized
      #   calculations.
      if ($spinPol == 2)
         {`($bin/OLCAOkkc $optcLines 2 2>&1)`;}
   }

   # Check for the existance of the fort.2 file that signals completion of
   #   the fortran executable without abortive error.
   if (! -e "fort.2")
      {&olcao_exit("Fortran success file missing.  Exiting Script.");}
   else
      {system ("rm -f fort.2");}
}



sub manageOutput
{
   # Define passed parameters.
   my $taskName  = $_[0];
   my $taskBasis = $_[1];
   my $taskEdge  = $_[2];
   my $taskKP    = $_[3];
   my $alt       = $_[4];

   # Define the temporary basis tag.
   my $tempBasis = "-temp";

   # Perform these specialized moves and copies for each possible task.
   if ("$taskName" eq "$setup")
      {&move("$setup$tempBasis$hdf","$setup$taskBasis$alt$hdf");}
   elsif ("$taskName" eq "$main")
   {
      &copy("fort.7","$taskEdge$main$taskBasis.$iteration$alt.7");
      &move("fort.7","$proj_dir/$taskEdge$iteration$taskBasis$alt$dat");
      &copy("fort.14","$taskEdge$main$taskBasis.$iteration$alt.14");
      &move("fort.14","$proj_dir/$taskEdge$energy$taskBasis$alt$dat");
      if ($spinPol == 1)
         {&copy("fort.8","$taskEdge$main$taskBasis.SCFV$alt.8");}
      else
      {
         &copy("fort.8","$taskEdge$main$taskBasis.sSCFV$alt.8");
         &copy("fort.13","$taskEdge$main$taskBasis.$moment$alt.13");
         &move("fort.13","$proj_dir/$taskEdge$moment$taskBasis$alt$dat");
      }
      &move("fort.8","$proj_dir/$taskEdge$initPot$taskBasis$alt$dat");
      if (-e "fort.1000")
      {
         &copy("fort.1000","$taskEdge$main$taskBasis.iterTDOS$alt.1000");
         &move("fort.1000",
               "$proj_dir/$taskEdge$main$taskBasis.iterTDOS$alt$plot");
      }
      &move("$setup$tempBasis$hdf","$setup$taskBasis$alt$hdf");
      &move("$main$tempBasis$hdf","$taskEdge$main$taskBasis$alt$hdf");
      if ($dosRunSCF == 1)
      {
         if ($spinPol == 2)
         {
            &copy("fort.60","$taskEdge$dos$taskBasis$tdos$alt$plot.60");
            &move("fort.60",
                  "$proj_dir/$taskEdge$dos$taskBasis$tdos$alt$up$plot");
            &copy("fort.70","$taskEdge$dos$taskBasis$pdos$alt$raw.70");
            &move("fort.70",
                  "$proj_dir/$taskEdge$dos$taskBasis$pdos$alt$up$raw");
            &copy("fort.80","$taskEdge$dos$taskBasis$loci$alt$plot.80");
            &move("fort.80",
                  "$proj_dir/$taskEdge$dos$taskBasis$loci$alt$up$plot");
            &copy("fort.61","$taskEdge$dos$taskBasis$tdos$alt$plot.61");
            &move("fort.61",
                  "$proj_dir/$taskEdge$dos$taskBasis$tdos$alt$dn$plot");
            &copy("fort.71","$taskEdge$dos$taskBasis$pdos$alt$raw.71");
            &move("fort.71",
                  "$proj_dir/$taskEdge$dos$taskBasis$pdos$alt$dn$raw");
            &copy("fort.81","$taskEdge$dos$taskBasis$loci$alt$plot.81");
            &move("fort.81",
                  "$proj_dir/$taskEdge$dos$taskBasis$loci$alt$dn$plot");
         }
         else
         {
            &copy("fort.60","$taskEdge$dos$taskBasis$tdos$alt$plot.60");
            &move("fort.60","$proj_dir/$taskEdge$dos$taskBasis$tdos$alt$plot");
            &copy("fort.70","$taskEdge$dos$taskBasis$pdos$alt$raw.70");
            &move("fort.70","$proj_dir/$taskEdge$dos$taskBasis$pdos$alt$raw");
            &copy("fort.80","$taskEdge$dos$taskBasis$loci$alt$plot.80");
            &move("fort.80","$proj_dir/$taskEdge$dos$taskBasis$loci$alt$plot");
         }
      }
      if ($bondRunSCF == 1)
      {
         if ($spinPol == 2)
         {
            &copy("fort.10","$taskEdge$bond$taskBasis$alt$raw.10");
            &move("fort.10","$proj_dir/$taskEdge$bond$taskBasis$alt$up$raw");
            &copy("fort.11","$taskEdge$bond$taskBasis$alt$raw.11");
            &move("fort.11","$proj_dir/$taskEdge$bond$taskBasis$alt$dn$raw");
         }
         else
         {
            &copy("fort.10","$taskEdge$bond$taskBasis$raw.10");
            &move("fort.10","$proj_dir/$taskEdge$bond$taskBasis$raw");
         }
      }
   }
   elsif ("$taskName" eq "$intg")
   {
      &move("$intg$tempBasis$hdf","$taskEdge$intg$taskBasis$alt$hdf");
      if ($spinPol == 1)
         {&move("fort.8","$taskEdge$intg$taskBasis.SCFV$alt.8");}
      else
         {&move("fort.8","$taskEdge$intg$taskBasis.sSCFV$alt.8");}
   }
   elsif ("$taskName" eq "$band")
   {
      &move("$intg$tempBasis$hdf","$taskEdge$intg$taskBasis$alt$hdf");
      &move("$band$tempBasis$hdf","$taskEdge$band$taskBasis$alt$hdf");
   }
   elsif ("$taskName" eq "$sybd")
   {
      &move("$intg$tempBasis$hdf","$taskEdge$intg$taskBasis$alt$hdf");
      if ($spinPol == 2)
      {
         &move("fort.31","$taskEdge$sybd$taskBasis$alt$raw.31");
         &move("fort.41","$proj_dir/$taskEdge$sybd$taskBasis$alt$up$plot");
         &move("fort.32","$taskEdge$sybd$taskBasis$alt$raw.32");
         &move("fort.42","$proj_dir/$taskEdge$sybd$taskBasis$alt$dn$plot");
      }
      else
      {
         &move("fort.31","$taskEdge$sybd$taskBasis$alt$raw.31");
         &move("fort.41","$proj_dir/$taskEdge$sybd$taskBasis$alt$plot");
      }
   }
   elsif ("$taskName" eq "$dos")
   {
      &move("$band$tempBasis$hdf","$taskEdge$band$taskBasis$alt$hdf");
      if ($spinPol == 2)
      {
         &copy("fort.60","$taskEdge$dos$taskBasis$tdos$plot$alt.60");
         &move("fort.60","$proj_dir/$taskEdge$dos$taskBasis$tdos$alt$up$plot");
         &copy("fort.70","$taskEdge$dos$taskBasis$pdos$alt$raw.70");
         &move("fort.70","$proj_dir/$taskEdge$dos$taskBasis$pdos$alt$up$raw");
         &copy("fort.80","$taskEdge$dos$taskBasis$loci$alt$plot.80");
         &move("fort.80","$proj_dir/$taskEdge$dos$taskBasis$loci$alt$up$plot");
         &copy("fort.61","$taskEdge$dos$taskBasis$tdos$alt$plot.61");
         &move("fort.61","$proj_dir/$taskEdge$dos$taskBasis$tdos$alt$dn$plot");
         &copy("fort.71","$taskEdge$dos$taskBasis$pdos$alt$raw.71");
         &move("fort.71","$proj_dir/$taskEdge$dos$taskBasis$pdos$alt$dn$raw");
         &copy("fort.81","$taskEdge$dos$taskBasis$loci$alt$plot.81");
         &move("fort.81","$proj_dir/$taskEdge$dos$taskBasis$loci$alt$dn$plot");
      }
      else
      {
         &copy("fort.60","$taskEdge$dos$taskBasis$tdos$plot$alt.60");
         &move("fort.60","$proj_dir/$taskEdge$dos$taskBasis$tdos$alt$plot");
         &copy("fort.70","$taskEdge$dos$taskBasis$pdos$alt$raw.70");
         &move("fort.70","$proj_dir/$taskEdge$dos$taskBasis$pdos$alt$raw");
         &copy("fort.80","$taskEdge$dos$taskBasis$loci$alt$plot.80");
         &move("fort.80","$proj_dir/$taskEdge$dos$taskBasis$loci$alt$plot");
      }
   }
   elsif ("$taskName" eq "$bond")
   {
      &move("$band$tempBasis$hdf","$taskEdge$band$taskBasis$alt$hdf");
      if ($spinPol == 2)
      {
         &copy("fort.10","$taskEdge$bond$taskBasis$alt$raw.10");
         &move("fort.10","$proj_dir/$taskEdge$bond$taskBasis$alt$up$raw");
         &copy("fort.11","$taskEdge$bond$taskBasis$alt$raw.11");
         &move("fort.11","$proj_dir/$taskEdge$bond$taskBasis$alt$dn$raw");
      }
      else
      {
         &copy("fort.10","$taskEdge$bond$taskBasis$alt$raw.10");
         &move("fort.10","$proj_dir/$taskEdge$bond$taskBasis$alt$raw");
      }
   }
   elsif ("$taskName" eq "$optc")
   {
      if ($spinPol == 2)
      {
         &move("$intg$tempBasis$hdf","$taskEdge$intg$taskBasis$alt$hdf");
         &move("$band$tempBasis$hdf","$taskEdge$band$taskBasis$alt$hdf");
         &copy("fort.40","$taskEdge$optc$taskBasis$cond$alt$up.40");
         &copy("fort.50","$taskEdge$optc$taskBasis$eps2$alt$up.50");
         &move("fort.40",
            "$proj_dir/$taskEdge$optc$taskBasis$cond$alt$up$plot");
         &move("fort.50",
            "$proj_dir/$taskEdge$optc$taskBasis$eps2$alt$up$plot");
         &move("fort.100","$proj_dir/$taskEdge$optc$taskBasis$alt$up$plot");
         &move("fort.110",
            "$proj_dir/$taskEdge$optc$taskBasis$eps1$alt$up$plot");
         &move("fort.120",
            "$proj_dir/$taskEdge$optc$taskBasis$elf$alt$up$plot");
         &move("fort.130",
            "$proj_dir/$taskEdge$optc$taskBasis$ref$alt$up$plot");
         &move("fort.140",
            "$proj_dir/$taskEdge$optc$taskBasis$eps1i$alt$up$plot");

         &copy("fort.41","$taskEdge$optc$taskBasis$cond$alt$dn.41");
         &copy("fort.51","$taskEdge$optc$taskBasis$eps2$alt$dn.51");
         &move("fort.41",
            "$proj_dir/$taskEdge$optc$taskBasis$cond$alt$dn$plot");
         &move("fort.51",
            "$proj_dir/$taskEdge$optc$taskBasis$eps2$alt$dn$plot");
         &move("fort.101",
            "$proj_dir/$taskEdge$optc$taskBasis$alt$dn$plot");
         &move("fort.111",
            "$proj_dir/$taskEdge$optc$taskBasis$eps1$alt$dn$plot");
         &move("fort.121",
            "$proj_dir/$taskEdge$optc$taskBasis$elf$alt$dn$plot");
         &move("fort.131",
            "$proj_dir/$taskEdge$optc$taskBasis$ref$alt$dn$plot");
         &move("fort.141",
            "$proj_dir/$taskEdge$optc$taskBasis$eps1i$alt$dn$plot");
      }
      else
      {
         &move("$intg$tempBasis$hdf","$taskEdge$intg$taskBasis$alt$hdf");
         &move("$band$tempBasis$hdf","$taskEdge$band$taskBasis$alt$hdf");
         &copy("fort.40","$taskEdge$optc$taskBasis$cond$alt.40");
         &copy("fort.50","$taskEdge$optc$taskBasis$eps2$alt.50");
         &move("fort.40","$proj_dir/$taskEdge$optc$taskBasis$cond$alt$plot");
         &move("fort.50","$proj_dir/$taskEdge$optc$taskBasis$eps2$alt$plot");
         &move("fort.100","$proj_dir/$taskEdge$optc$taskBasis$alt$plot");
         &move("fort.110","$proj_dir/$taskEdge$optc$taskBasis$eps1$alt$plot");
         &move("fort.120","$proj_dir/$taskEdge$optc$taskBasis$elf$alt$plot");
         &move("fort.130","$proj_dir/$taskEdge$optc$taskBasis$ref$alt$plot");
         &move("fort.140","$proj_dir/$taskEdge$optc$taskBasis$eps1i$alt$plot");
      }
   }
   elsif ("$taskName" eq "$sige")
   {
      &move("$intg$tempBasis$hdf","$taskEdge$intg$taskBasis$alt$hdf");
      &move("$band$tempBasis$hdf","$taskEdge$band$taskBasis$alt$hdf");
      if ($spinPol == 2)
      {
         &copy("fort.50","$taskEdge$sige$taskBasis$cond$alt$up.50");
         &move("fort.50",
            "$proj_dir/$taskEdge$sige$taskBasis$cond$alt$up$plot");
         &copy("fort.51","$taskEdge$sige$taskBasis$cond$alt$dn.51");
         &move("fort.51",
            "$proj_dir/$taskEdge$sige$taskBasis$cond$alt$dn$plot");
      }
      else
      {
         &copy("fort.50","$taskEdge$sige$taskBasis$cond$alt.50");
         &move("fort.50","$proj_dir/$taskEdge$sige$taskBasis$cond$alt$plot");
      }
   }
   elsif ("$taskName" eq "$pacs")
   {
      &move("$intg$tempBasis$hdf","gs_$intg$taskBasis$alt$hdf");
      &move("$band$tempBasis$hdf","gs_$band$taskBasis$alt$hdf");
      &move("$band$tempBasis.2$hdf","$taskEdge$band$taskBasis$alt$hdf");
      if ($spinPol == 2)
      {
         &copy("fort.50","$taskEdge$pacs$taskBasis$alt$plot$up.50");
         &move("fort.50","$proj_dir/$taskEdge$pacs$taskBasis$alt$up$plot");
         &copy("fort.51","$taskEdge$pacs$taskBasis$alt$plot$dn.51");
         &move("fort.51","$proj_dir/$taskEdge$pacs$taskBasis$alt$dn$plot");
      }
      else
      {
         &copy("fort.50","$taskEdge$pacs$taskBasis$alt$plot.50");
         &move("fort.50","$proj_dir/$taskEdge$pacs$taskBasis$alt$plot");
      }
   }
   elsif ("$taskName" eq "$wave")
   {
      &move("$band$tempBasis$hdf","$taskEdge$band$taskBasis$alt$hdf");
      if ($spinPol == 1)
         {&move("fort.8","$taskEdge$intg$taskBasis.SCFV$alt.8");}
      else
         {&move("fort.8","$taskEdge$intg$taskBasis.sSCFV$alt.8");}

      # The profile files are always created.
      &move("fort.30","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                      "$profile-a$dat");
      &move("fort.31","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                      "$profile-b$dat");
      &move("fort.32","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                      "$profile-c$dat");
      if (-e "fort.56") # Only move openDX files if they were created.
      {
         &move("fort.56","$proj_dir/$atomPos$dx");
         &move("fort.57","$proj_dir/$lattice$dx");
         if ($spinPol == 2)
         {
            &move("fort.58","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                            "$valeRho$upPdn$dx");
            &move("fort.59","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                            "$valeRho$upMdn$dx");
            &move("fort.60","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                            "$valeRho$upPdn$minusNeut$dx");
            &move("fort.61","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                            "$pot$up$dx");
            &move("fort.62","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                            "$pot$dn$dx");
         }
         else
         {
            &move("fort.58","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                            "$valeRho$dx");
            &move("fort.59","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                            "$valeRho$minusNeut$dx");
            &move("fort.60","$proj_dir/$taskEdge$wave$taskBasis$alt" .
                            "$pot$dx");
         }
      }
   }

   # Perform these moves for all tasks.
   &move("fort.5", "$taskEdge$taskName$taskBasis$dat.5");
   &move("fort.15","$taskKP.15");
   &move("fort.4", "$structure$dat.4");
   &copy("fort.20","$taskEdge$taskName$taskBasis$alt$out.20");
   &move("fort.20","$proj_dir/$taskEdge$taskName$taskBasis$alt$out");
}


sub updatePACS
{
   # This subroutine is run after both main calculations for the XAS 
   #   total calculation are complete.  Then, we can determine the approximate
   #   location of the edge onset based on the total energy difference between
   #   the two states (initial/final).

   # Define passed parameters.
   my $finMainEdge      = "$_[0]"."_";
   my $updateSCFBasis   = "-"."$_[1]";

   # Define local variables.
   my $line;
   my @values;
   my $initEnergy;
   my $finEnergy;
   my $TEDiff;
   my $unknownFound;
   my $numCoreOrbitals;
   my $orbital;

   chdir $proj_dir;

   open (INITMAIN,"<gs_$main$updateSCFBasis$out") ||
         die "Cannot open gs_$main$updateSCFBasis$out for reading.\n";
   open (FINMAIN,"<$finMainEdge$main$updateSCFBasis$out") ||
         die "Cannot open $finMainEdge$main$updateSCFBasis$out for writing\n";

   # Find the total energy of the initial state.
   while ($line=<INITMAIN>)
   {
      if ($line=~/TOTAL ENERGY/)
      {
         chomp $line;
         @values=split(/\s+/,"$line");
         $initEnergy=$values[$#values];
      }
   }
   close(INITMAIN);

   # Find the total energy of the final state.
   while ($line=<FINMAIN>)
   {
      if ($line=~/TOTAL ENERGY/)
      {
         chomp $line;
         @values=split(/\s+/,"$line");
         $finEnergy=$values[$#values];
      }
   }
   close(FINMAIN);

   # Use the collected info to determine the total energy difference (TEdiff).
   $TEDiff = abs($finEnergy-$initEnergy)*StructureControl::getHartree();

   # It is assumed that the pacs input file already exists at this point.
   #   We are just going to replace the "UNKNOWN" values.

   open (PACSOLD,"<$olcao$dat") || die "Cannot open $olcao$dat for reading.\n";
   open (PACSNEW,">pacs_temp") || die "Cannot open pacs_temp for writing.\n";

   $unknownFound=0;
   while($line=<PACSOLD>)
   {
      if ($line=~/PACS_INPUT_DATA/)
      {
         print PACSNEW $line;
         $line=<PACSOLD>;
         print PACSNEW $line;
         $line=<PACSOLD>;
         print PACSNEW $line;
         $line=<PACSOLD>;
         print PACSNEW $line;
         $line=<PACSOLD>;
         print PACSNEW $line;

         @values = StructureControl::prepLine("",$line,'\s+');
         $numCoreOrbitals = $values[0];

         foreach $orbital (1..$numCoreOrbitals)
         {
            $line=<PACSOLD>;
            @values = StructureControl::prepLine("",$line,'\s+');
            if (($values[4] == -1) && ($values[0] == $QN_n) &&
                ($values[1] == $QN_l))
            {
               print PACSNEW "@values[0..3] $TEDiff $values[5]\t ".
                  " QN_n QN_l Init1 Init2 TEDiff\n";
               $unknownFound = 1;
            }
            else
               {print PACSNEW $line;}
         }
      }
      else
         {print PACSNEW "$line";}
   }

   close (PACSOLD);
   close (PACSNEW);

   # Update the version of the pacs input file in the inputs directory
   &move ("pacs_temp","$olcao$dat");

   # Only print a notice if we changed anything.
   if ($unknownFound==1)
      {print RUNTIME "$olcao$dat Updated.\n";}
}


sub cleanUp
{
   system("rm $temp/$OLCAOlock");
   print RUNTIME "Program Sequence Complete.\n";
   close RUNTIME;
}

#Close the MPI interface
MPI_Finalize();
